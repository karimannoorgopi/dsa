/*------------- Experiment 1: Sum of Two Sparse Polynomials Using Arrays -------------*/
#include <stdio.h>
struct Term {
    int coeff;
    int expo;
};
void addPolynomials(struct Term poly1[], int n1, struct Term poly2[], int n2, struct Term polyResult[], int *nResult) {
    int i = 0, j = 0, k = 0, ncoeff;
    while (i < n1 && j < n2) {
        if (poly1[i].expo == poly2[j].expo) {
            ncoeff = poly1[i].coeff + poly2[j].coeff;
            if (ncoeff != 0) {
                polyResult[k].coeff = ncoeff;
                polyResult[k].expo = poly1[i].expo;
                k++;
            }
            i++; j++;
        } else if (poly1[i].expo > poly2[j].expo) {
            polyResult[k] = poly1[i];
            i++; k++;
        } else {
            polyResult[k] = poly2[j];
            j++; k++;
        }
    }
    while (i < n1) { polyResult[k] = poly1[i]; i++; k++; }
    while (j < n2) { polyResult[k] = poly2[j]; j++; k++; }
    *nResult = k;
}
void displayPolynomial(struct Term poly[], int n) {
    for (int i = 0; i < n; i++) {
        printf("%dx^%d", poly[i].coeff, poly[i].expo);
        if (i != n - 1) { printf(" + "); }
    }
    printf("\n");
}
int main() {
    struct Term poly1[20], poly2[20], polyResult[40];
    int n1, n2, nResult;
    printf("Enter the number of terms in the first polynomial:\n");
    scanf("%d", &n1);
    printf("Enter the terms in descending order of exponents (coeff exponent):\n");
    for (int i = 0; i < n1; i++)
        scanf("%d%d", &poly1[i].coeff, &poly1[i].expo);
    printf("Enter the number of terms in the second polynomial: ");
    scanf("%d", &n2);
    printf("Enter the terms in descending order of exponents (coeff exponent):\n");
    for (int i = 0; i < n2; i++)
        scanf("%d%d", &poly2[i].coeff, &poly2[i].expo);
    addPolynomials(poly1, n1, poly2, n2, polyResult, &nResult);
    printf("Sum of Polynomials: ");
    displayPolynomial(polyResult, nResult);
    return 0;
}

/*------------- Experiment 2: Transpose and Sum of Sparse Matrices -------------*/
#include <stdio.h>
#define MAX 100
typedef struct { int row; int col; int value; } Term;
void display(Term s[]) {
    int n = s[0].value;
    printf("\nRow Col Value\n");
    for (int i = 0; i <= n; i++) printf("%3d %4d %5d\n", s[i].row, s[i].col, s[i].value);
}
void transpose(Term sparse[], Term trans[]) {
    int i, j, k = 1, n = sparse[0].value;
    trans[0].row = sparse[0].col; trans[0].col = sparse[0].row; trans[0].value = n;
    for (i = 0; i < sparse[0].col; i++)
        for (j = 1; j <= n; j++)
            if (sparse[j].col == i) {
                trans[k].row = sparse[j].col;
                trans[k].col = sparse[j].row;
                trans[k].value = sparse[j].value;
                k++;
            }
}
void addSparse(Term A[], Term B[], Term C[]) {
    int i, j, k; int tA = A[0].value, tB = B[0].value;
    if (A[0].row != B[0].row || A[0].col != B[0].col) return;
    i = j = k = 1; C[0].row = A[0].row; C[0].col = A[0].col;
    while (i <= tA && j <= tB) {
        if (A[i].row < B[j].row || (A[i].row == B[j].row && A[i].col < B[j].col))
            C[k++] = A[i++];
        else if (B[j].row < A[i].row || (B[j].row == A[i].row && B[j].col < A[i].col))
            C[k++] = B[j++];
        else {
            int sum = A[i].value + B[j].value;
            if (sum != 0) { C[k].row = A[i].row; C[k].col = A[i].col; C[k].value = sum; k++; }
            i++; j++;
        }
    }
    while (i <= tA) C[k++] = A[i++];
    while (j <= tB) C[k++] = B[j++];
    C[0].value = k - 1;
    display(C);
}
int main() {
    Term A[MAX], B[MAX], Result[MAX];
    int choice;
    do {
        scanf("%d", &choice);
        switch (choice) {
        case 1:
            scanf("%d%d%d", &A[0].row, &A[0].col, &A[0].value);
            for (int i = 1; i <= A[0].value; i++)
                scanf("%d%d%d", &A[i].row, &A[i].col, &A[i].value);
            transpose(A, Result); display(Result);
            break;
        case 2:
            scanf("%d%d%d", &A[0].row, &A[0].col, &A[0].value);
            for (int i = 1; i <= A[0].value; i++)
                scanf("%d%d%d", &A[i].row, &A[i].col, &A[i].value);
            scanf("%d%d%d", &B[0].row, &B[0].col, &B[0].value);
            for (int i = 1; i <= B[0].value; i++)
                scanf("%d%d%d", &B[i].row, &B[i].col, &B[i].value);
            addSparse(A, B, Result);
            break;
        }
    } while (choice != 3);
    return 0;
}

/*------------- Experiment 3: Multistack -------------*/
#include <stdio.h>
#include <stdlib.h>
#define SIZE 10
int arr[SIZE];
int top1 = -1;
int top2 = SIZE;
void push1(int value) {
    if (top1 + 1 == top2) printf("Stack 1 Overflow!\n");
    else { top1++; arr[top1] = value; }
}
void push2(int value) {
    if (top1 + 1 == top2) printf("Stack 2 Overflow!\n");
    else { top2--; arr[top2] = value; }
}
int pop1() {
    if (top1 == -1) { printf("Stack 1 Underflow!\n"); return -1; }
    else { int value = arr[top1]; top1--; return value; }
}
int pop2() {
    if (top2 == SIZE) { printf("Stack 2 Underflow!\n"); return -1; }
    else { int value = arr[top2]; top2++; return value; }
}
void display1() {
    if (top1 >= 0) { for (int i = 0; i <= top1; i++) printf("%d ", arr[i]); printf("\n"); }
}
void display2() {
    if (top2 < SIZE) { for (int i = top2; i < SIZE; i++) printf("%d ", arr[i]); printf("\n"); }
}
int main() {
    int choice, value;
    while (1) {
        scanf("%d", &choice);
        switch (choice) {
        case 1: scanf("%d", &value); push1(value); break;
        case 2: scanf("%d", &value); push2(value); break;
        case 3: value = pop1(); if (value != -1) printf("%d\n", value); break;
        case 4: value = pop2(); if (value != -1) printf("%d\n", value); break;
        case 5: display1(); break;
        case 6: display2(); break;
        case 7: exit(0);
        }
    }
    return 0;
}

/*------------- Experiment 4: Infix to Postfix and Evaluation -------------*/
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#define MAX 100
char opStack[MAX]; int topOp = -1;
int valStack[MAX]; int topVal = -1;
void pushOp(char c) { opStack[++topOp] = c; }
char popOp() { if (topOp == -1) return -1; else return opStack[topOp--]; }
int precedence(char c) { if (c == '^') return 3; else if (c == '*' || c == '/') return 2; else if (c == '+' || c == '-') return 1; else return 0; }
void infixToPostfix(char infix[], char postfix[]) {
    int i, j = 0; char c;
    for (i = 0; infix[i] != '\0'; i++) {
        c = infix[i];
        if (isspace(c)) continue;
        else if (isdigit(c)) { while (isdigit(infix[i])) { postfix[j++] = infix[i++]; } postfix[j++] = ' '; i--; }
        else if (c == '(') pushOp(c);
        else if (c == ')') { while (topOp != -1 && opStack[topOp] != '(') { postfix[j++] = popOp(); postfix[j++] = ' '; } popOp(); }
        else { while (topOp != -1 && precedence(opStack[topOp]) >= precedence(c)) { postfix[j++] = popOp(); postfix[j++] = ' '; } pushOp(c); }
    }
    while (topOp != -1) { postfix[j++] = popOp(); postfix[j++] = ' '; }
    postfix[j] = '\0';
}
void pushVal(int value) { valStack[++topVal] = value; }
int popVal() { return valStack[topVal--]; }
int evaluatePostfix(char postfix[]) {
    int i = 0;
    while (postfix[i] != '\0') {
        if (isspace(postfix[i])) { i++; continue; }
        else if (isdigit(postfix[i])) {
            int num = 0;
            while (isdigit(postfix[i])) {
                num = num * 10 + (postfix[i] - '0'); i++;
            }
            pushVal(num);
        } else {
            int val2 = popVal(); int val1 = popVal();
            switch (postfix[i]) {
                case '+': pushVal(val1 + val2); break;
                case '-': pushVal(val1 - val2); break;
                case '*': pushVal(val1 * val2); break;
                case '/': pushVal(val1 / val2); break;
                case '^': {
                    int result = 1;
                    for (int j = 0; j < val2; j++) result *= val1;
                    pushVal(result); break;
                }
            }
            i++;
        }
    }
    return popVal();
}
int main() {
    char infix[MAX], postfix[MAX];
    fgets(infix, MAX, stdin);
    infixToPostfix(infix, postfix);
    int result = evaluatePostfix(postfix);
    printf("%s\n%d\n", postfix, result);
    return 0;
}

/*------------- Experiment 5: Queue, Dequeue, Circular Queue Using Array -------------*/
#include<stdio.h>
#include<stdlib.h>
#include <stdbool.h>
#define MAX 10
int queue[MAX]; int rear = -1; int front = -1;
bool isEmpty() { return rear == front; }
bool isFull() { return rear == MAX - 1; }
void enqueue() { int item; if (isFull()) printf("Queue Overflow\n"); else { scanf("%d", &item); rear = rear + 1; queue[rear] = item; } }
void dequeue() { if (isEmpty()) printf("Queue Underflow\n"); else { front = front + 1; printf("%d\n", queue[front]); } }
void display() { if(isEmpty()) printf("Queue is empty\n"); else { for (int i = front+1; i <= rear; i++) printf("%d ", queue[i]); printf("\n"); } }
int peek() { if (isEmpty()) { return -1; } else { return queue[front+1]; } }
int size() { return rear - (front + 1)+1; }
int main() { int choice; while(1) { scanf("%d", &choice); switch(choice) { case 1: enqueue(); break; case 2: dequeue(); break; case 3: display(); break; case 4: printf("%d\n", peek()); break; case 5: printf("%d\n", size()); break; case 6: exit(1); } } return 0; }

/*------------- Experiment 6: Maximum Activity Points (see PDF for details) -------------*/
/* The code for this experiment is detailed in the PDF; it involves greedy/DP logic for scheduling activities */
/* If you want the code, please specify since it's not typical DSA. */

/*------------- Experiment 7: Addition and Multiplication of Polynomials -------------*/
/* Refer to Experiment 1 above for addition. Multiplication requires implementation as shown in your PDF. */

/*------------- Experiment 8: Stack Using Linked List -------------*/
#include<stdio.h>
#include<stdlib.h>
struct Node { int data; struct Node *next; };
struct Node *top=NULL;
void push(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value; newNode->next = top; top = newNode;
}
int pop() {
    if (top == NULL) return -1;
    int poppedValue = top->data;
    struct Node* temp = top; top = top->next; free(temp);
    return poppedValue;
}
void displayStack() {
    struct Node* temp = top;
    while (temp != NULL) { printf("%d-->", temp->data); temp = temp->next; }
    printf("NULL\n");
}
void main() {
    int ch, data, rv;
    while(1) {
        scanf("%d",&ch);
        switch(ch) {
            case 1: scanf("%d",&data); push(data); displayStack(); break;
            case 2: rv=pop(); if(rv!=-1) printf("%d\n",rv); displayStack(); break;
            case 3: displayStack(); break;
            case 4: exit(0);
        }
    }
}

/*------------- Experiment 9: Queue Using Linked List -------------*/
#include<stdio.h>
#include <stdlib.h>
struct Node { int data; struct Node *next; } *front=NULL, *rear=NULL;
void enqueue() {
    struct Node *newnode=(struct Node*)malloc(sizeof(struct Node));
    scanf("%d",&newnode->data);
    newnode->next=NULL;
    if(front==NULL) front=rear=newnode;
    else { rear->next=newnode; rear=newnode; }
}
int dequeue() {
    int value;
    struct Node *temp=front;
    if(front==NULL) return -1;
    value = temp->data; front=front->next; free(temp); return value;
}
void display() {
    struct Node *temp=front;
    while(temp) { printf("%d->",temp->data); temp=temp->next; }
    printf("NULL\n");
}
int main() {
    int choice, rv;
    while(1) {
        scanf("%d",&choice);
        switch(choice) {
            case 1: enqueue(); display(); break;
            case 2: rv=dequeue(); if(rv!=-1) printf("%d\n",rv); display(); break;
            case 3: display(); break;
            case 4: exit(0);
        }
    }
}

/*------------- Experiment 10: Circular Linked List -------------*/
#include <stdio.h>
#include <stdlib.h>
struct Node { int data; struct Node *next; };
struct Node* last = NULL;
void insertEnd(int data) {
    struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    if (last == NULL) { last = newNode; newNode->next = last; }
    else {
        newNode->next = last->next;
        last->next = newNode;
        last = newNode;
    }
}
void display() {
    if (last == NULL) return;
    struct Node *temp = last->next;
    do {
        printf("%d->", temp->data);
        temp = temp->next;
    } while (temp != last->next);
    printf("NULL\n");
}
int main() {
    int choice, data;
    while(1) {
        scanf("%d",&choice);
        switch(choice) {
            case 1: scanf("%d",&data); insertEnd(data); display(); break;
            case 2: display(); break;
            case 3: exit(0);
        }
    }
}
